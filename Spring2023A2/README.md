# Explanation to A2

## A2Q1 多项式乘法

要求：首先给出测试数据 $T$，然后输入 $T$ 组测试数据：一组测试数据有两行，第一个数字 $n$ 标识多项式的项数，其余 $n$ 个数字分别标识多项式中的各项的系数。

难度：中等

做法：这个是一道模拟题，输入后首先能够得到结果数组的长度为 $m + n - 1$，然后使用二重for循环模拟相乘即可。

提示：不需要考虑下标和次方之间的对应关系，原因是次方数的先后顺序不会影响系数的结果：

$(3x+2)*(4x+1) = 12x^2+11x+2$

$(3+2x)*(4+1x) = 12 + 11x + 2x^2$

下面的式子逆转了上面式子的次方数，但是系数的顺序依然是不变的，因此不需要考虑下标和次方之间的对应关系。

## A2Q2 领域扩散

要求：给定 $m×n$大小的地图，其中有Wall，Land和Brand。每个单位时间，Brand会向上下左右4个方向扩散，将Land变化为Brand。需要使用模拟的方法，计算 $k$个单位时间后的地图情况。

难度：中等+

做法：这也是一道模拟题，需要模拟 $k$个单位时间的变化。循环 $k$次，每次做如下操作：

（1）创建一个和原地图完全相同的地图副本的二维数组。

（2）使用原地图的信息，在地图副本上做修改。搜索原地图上的B，将地图副本相应位置的周围的L变为B。

（3）将变化好的地图副本信息还原给原地图信息

注意：上下左右做设置的时候，需要做边界检查！

## A2Q3 回文子串

要求：给出测试数据组数 $T$，每组测试数据给出一个字符串，然后需要返回其中有多少个子串是“回文字符串”。

难度：简单

做法：二重循环枚举所有的子字符串，然后逐一检查子字符串是否是回文串。

提示：
1. 截取子字符串的方法：`substring()`
2. 获取`s`字符串的倒序：`new StringBuilder(s).reverse().toString()`
3. 判断字符串是否相等的方法：`equals()`

## A2Q4 数组复原

要求：给出数组长度 $n$和请求接口`Judge.query(int a, int b, int c)`，该接口接收三个数组的下标，会返回在这个数组的三个位置中，0的个数多还是1的个数多。需要实现对数组的复原操作。

难度：
- 110分：简单
- 120分：中等
- 130分：困难

做法：

这个题的Hint2的含金量特别高，隐藏的信息特别多，需要反复研究这句话背后的深意！

**【110分】**

1. 构建目标int数组和标志是否知晓答案的boolean数组：默认值分别是0和false。

2. 构建请求结果数组：使用一个长度为3的循环滑动窗口，从数组头部推进到尾部做逐一的`Judge.query`，其中如果元素下标出现了越界，就将数组的下标对数组长度取模以实现一个循环滑动窗口。将这些滑动窗口的Query结果保存起来。

3. 复原数组第一阶段：Hint中第二条提示了做法。遍历请求结果数组及其下一个元素，如果一个结果为0而另一个结果为1，那么就可以确定两个元素的结果。确定结果后，更新目标int数组和是否知晓答案的boolean数组。

举个例子来说，对于下面长度为6的数组，淡蓝色是红色+2个黄色的请求结果，深蓝色是2个黄色+绿色的请求结果。他们两个的Query结果不同，因此我们可以推断变化的左右两翼（下标0和下标3）一定影响了Query的结果，因此我们可以推断下标0的位置是0，下标3的位置是1。

![image](https://user-images.githubusercontent.com/64548919/226078222-4555420b-ee54-4dad-bea4-0a6061b16c8b.png)

在这个过程中，如果确定数组元素是0或者1，需要保存至少1个元素为0的下标 $index_0$和1个元素为1的下标 $index_1$。

4. 复原数组第二阶段：我们现在已知了元素为0的下标 $index_0$和元素为1的下标 $index_1$，现在就可以使用它们来确定任意下标 $i$的数组元素了，`Judge.query(i, index_0, index_1)`的结果就是数组中下标为 $i$的数组元素。

**【120分】**

123步和110分的做法保持一致。

4. 复原数组第二阶段：持续循环利用已知的数组元素信息做探索挖掘，直至无法探索出新的内容。然后找一个元素为0，一个元素为1和一个未知元素的三个下标进行一次query，增加已知的信息，然后继续持续循环利用直至无法探索……

探索的方法：
- 对于Query[i]来说，假定Query[i]是0（为1是类似的），那么就说明(i, i+1, i+2)这三个位置中，0的个数比1多。
  - 如果i是已知且目标int数组值为1，那么我们一定可以确定i+1和i+2的位置都是0
  - 如果i+1是已知且目标int数组值为1，那么类似可以确定i和i+2的位置都是0
  - 如果i+2是已知且目标int数组值为1，那么类似可以确定i和i+1的位置都是0
- 需要持续探索直至数组到达稳定态。
- 到达稳定态后，先检查是不是都知道答案了。如果有不知道答案的，就利用一次Query增加有用的信息，然后继续持续循环利用探索。

注意：循环滑动窗口需要对数组长度取模。

**【130分】**

这个做法需要对这个问题的理解程度比较高，才能做得出来。情况比较多，如果做不出来也没关系。

1. 构建目标int数组和标志是否知晓答案的boolean数组：默认值分别是0和false。

2. 构建长度为n/3的请求结果数组，其中数组下标为 $i$的元素保存`Judge.query(3*i, 3*i + 1, 3*i + 2)`的结果。

![image](https://user-images.githubusercontent.com/64548919/226260064-e59ce0e4-c089-4207-9223-922cf81034c9.png)

这一阶段我们需要 $\frac{n}{3}$次的询问。

3. 寻求Query结果数组的pivot（枢轴）：从1开始寻找直至n，pivot的条件是：`Query[pivot - 1] != Query[pivot]`。在上面的例子中，我们可以发现**pivot的值是2**（即淡蓝色区域的下标）。

4. 复原数组第一阶段：确定以`pivot*3`为中心的6个元素（在这张图中是绿色和蓝色区域）。确定这6个元素需要多次`Judge.query`询问。

![image](https://user-images.githubusercontent.com/64548919/226260409-bec9a81a-8571-4df3-892e-8dc6e664d58f.png)

- 尝试1：`Judge.query`询问4,5,6下标的元素：假定得到的结果是0，和3,4,5下标的询问结果不同，那么此次尝试成功，否则失败。

那么因为之前的结论，我们可以推断出下标3的元素是1，而下标6的元素是0。下标4和5暂不能推断，但我们可以得知其中必定一个0和一个1。根据之前110分的解法中，使用1个元素为1的下标和1个元素为0的下标可以确定任意下标的元素，我们使用一次`Judge.query`一石二鸟击破下标4和下标5。但是下标7和下标8也属于需要探索的区域但暂时未知，因此我们先记为unknown1和unknown2。

![image](https://user-images.githubusercontent.com/64548919/226260567-1c50b1a0-a317-4384-9cf8-0448501d88ef.png)

- 尝试2：如果尝试1失败，那么告诉我们一个结论，就是4,5,6的询问结果与3,4,5相同。尝试2就使用`Judge.query`询问5,6,7下标的元素：假定得到的结果是0，和4,5,6下标的询问结果不同，那么此次尝试成功，否则失败。

那么因为之前的结论，我们可以推断出下标4的元素是1，而下标7的元素是0。类似地，我们消耗一次`Judge.query`击破下标5和6，标记3和8为unknown。

![image](https://user-images.githubusercontent.com/64548919/226261838-024d78a4-0c07-495d-8b3c-89efb76a7acc.png)

- 尝试3：这是最后一次尝试，也是不需要询问的尝试。通过之前的失败，我们可以得知4,5,6的询问、5,6,7的询问都和3,4,5的询问结果相同，那么我们就可以得到结论：

```text
5,6,7的询问结果和6,7,8的询问结果不同
```

那么类似地，下标5和下标8可以确定，下标6和7可以用一次`Judge.query`击破。此时unknown为3和4。

![image](https://user-images.githubusercontent.com/64548919/226262685-985618f8-84f1-4d32-8428-61c21e1fe914.png)

- 确定两个unknown：这个操作属于是“秋后算账”。在上面的三次尝试中，我们可以确定某些元素是0或者1，那么我们就需要确定至少各一个元素为0和元素为1的下标 $index_0$和 $index_1$。按照之前的结论，我们使用 $index_0$和 $index_1$可以确定任意下标的元素。因此可以直接消耗两次`Judge.query`确定两个unknown的下标。

至此，复原数组第一阶段结束，以`3*pivot`为中心的6个元素全部被确定。这一阶段我们消耗至多 $3+2=5$次询问。

5. 复原数组第二阶段：对于剩余没有被确定 $n-6$个元素，使用 $index_0$和 $index_1$确定其余下标的元素。以3个为一组，回避之前已处理过的pivot中心区域，进行批处理。

【假定第一阶段复原pivot周围区域为下图所示， $index_0=3$, $index_1 = 5$】

![image](https://user-images.githubusercontent.com/64548919/226265219-617fbac9-d07d-4912-9956-8e5269d432d8.png)

以黄色区域的复原举例：

- 目前已知0,1,2的请求结果为1，那么说明1的个数比0多。
- 进行`Judge.query(1, 2, index_0)`
  - 情况1：得到的结果为1，和0,1,2相同。那么就说明一定下标1和下标2都是1，是影响0,1,2请求结果的主力军（因为如果1和2中有0的话，1,2,  $index_0$中至少2个0，那么`query`得到的结果就是0，出现矛盾）。但是此时我们还不能知道0下标的元素是什么，因此又消耗一次`Judge.query(0, index_0, index_1)`得到0下标的元素。
  - 情况2：得到的结果为0，和0,1,2不同。那么就说明一定下标1和下标2一定内部出现了分裂，一定是一个0和一个1（因为如果下标1和下标2中均为1的话，1,2, $index_0$中至少2个1，那么得到的结果就是1，出现矛盾；如果下标1和下标2均为0，那么0,1,2的请求结果就一定是0，出现矛盾）。但是此时我们还不能知道其中哪一个是0，哪一个是1，因此又消耗一次`Judge.query(0, index_0, index_1)`以得到下标1和下标2的元素。但注意之前下标1和下标2是一个0和一个1，0,1,2的请求结果却是1，就可以得到下标0的元素一定是1了。

这样依次循环未复原的区域，即可完成所有数组元素的复原。

在这一阶段，我们消耗 $(\frac{n}{3} - 2) × 2 = \frac{2n}{3} - 4$次询问。

统计一下，我们至多的询问次数是 $\frac{n}{3} + 5 + \frac{2n}{3} - 4 = n + 1 \le n + 1$次，因此在数学层面，我们这个解法可以符合130分的要求。
