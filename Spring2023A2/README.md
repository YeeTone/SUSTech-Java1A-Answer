# Explanation to A1

## A2Q1 多项式乘法

要求：首先给出测试数据$T$，然后输入$T$组测试数据：一组测试数据有两行，第一个数字$n$标识多项式的项数，其余$n$个数字分别标识多项式中的各项的系数。

难度：中等

做法：这个是一道模拟题，输入后首先能够得到结果数组的长度为$m + n - 1$，然后使用二重for循环模拟相乘即可。

提示：不需要考虑下标和次方之间的对应关系，原因是次方数的先后顺序不会影响系数的结果：

$(3x+2)*(4x+1) = 12x^2+11x+2$

$(3+2x)*(4+1x) = 12 + 11x + 2x^2$

下面的式子逆转了上面式子的次方数，但是系数的顺序依然是不变的，因此不需要考虑下标和次方之间的对应关系。

## A2Q2 领域扩散

要求：给定$m×n$大小的地图，其中有Wall，Land和Brand。每个单位时间，Brand会向上下左右4个方向扩散，将Land变化为Brand。需要使用模拟的方法，计算$k$个单位时间后的地图情况。

难度：中等+

做法：这也是一道模拟题，需要模拟$k$个单位时间的变化。循环$k$次，每次做如下操作：

（1）创建一个和原地图完全相同的地图副本的二维数组。

（2）使用原地图的信息，在地图副本上做修改。搜索原地图上的B，将地图副本相应位置的周围的L变为B。

（3）将变化好的地图副本信息还原给原地图信息

注意：上下左右做设置的时候，需要做边界检查！

## A2Q3 回文子串

要求：给出测试数据组数$T$，每组测试数据给出一个字符串，然后需要返回其中有多少个子串是“回文字符串”。

难度：简单

做法：二重循环枚举所有的子字符串，然后逐一检查子字符串是否是回文串。

提示：
1. 截取子字符串的方法：`substring()`
2. 获取`s`字符串的倒序：`new StringBuilder(s).reverse().toString()`
3. 判断字符串是否相等的方法：`equals()`

## A1Q4 数组复原

要求：给出数组长度$n$和请求接口`Judge.query(int a, int b, int c)`，该接口接收三个数组的下标，会返回在这个数组的三个位置中，0的个数多还是1的个数多。需要实现对数组的复原操作。

难度：困难（Tricky）

做法：
【110分】
- 构建目标int数组和标志是否知晓答案的boolean数组：默认值分别是0和false。
- 构建请求结果数组：使用一个长度为3的循环滑动窗口，从数组头部推进到尾部做逐一的`Judge.query`，其中如果元素下标出现了越界，就将数组的下标对数组长度取模以实现一个循环滑动窗口。将这些滑动窗口的Query结果保存起来。
- 复原数组第一阶段：Hint中第二条提示了做法。遍历请求结果数组及其下一个元素，如果一个结果为0而另一个结果为1，那么就可以确定两个元素的结果。确定结果后，更新目标int数组和是否知晓答案的boolean数组。

举个例子来说，对于下面长度为6的数组，淡蓝色是红色+2个黄色的请求结果，深蓝色是2个黄色+绿色的请求结果。他们两个的Query结果不同，因此我们可以推断变化的左右两翼（下标0和下标3）一定影响了Query的结果，因此我们可以推断下标0的位置是0，下标3的位置是1。

![image](https://user-images.githubusercontent.com/64548919/226078222-4555420b-ee54-4dad-bea4-0a6061b16c8b.png)

在这个过程中，如果确定数组元素是0或者1，需要保存至少1个元素为0的下标$index_o$和1个元素为1的下标$index_1$。

- 复原数组第二阶段：我们现在已知了元素为0的下标$index_0$和元素为1的下标$index_1$，现在就可以使用它们来确定任意下标$i$的数组元素了，`Judge.query(i, index_0, index_1)`的结果就是数组中下标为$i$的数组元素。


【130分】我暂时没有想到，想到的同学可以和我提出一下想法。

注意：循环滑动窗口需要对数组长度取模。