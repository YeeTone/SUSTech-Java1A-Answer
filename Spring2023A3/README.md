# Explanation to A3

## A3Q1 扫雷游戏

要求：给出扫雷游戏面板大小 $n$，以及内部雷区的分布情况，然后处理一次询问，询问点开特定位置 $(x,y)$后的实际情况。如果是雷则输出-1，否则输出周围雷的个数。

难度：简单

做法：这是一道二维数组的经典题目，也是2020年JavaA的project题目的简化版。首先判断是不是雷，是雷就直接输出-1结束；否则就往周围8个格子做探索，统计周围雷的个数。

注意：探索8个格子的时候，需要做边界检查以避免越界。

## A3Q2 红警战场安全区域

这是我出的一道题，因为我是红警HBK08和红警月亮3的忠实粉丝。目前圈内普遍认为，伊拉克和法国是这个游戏原版的综合实力最强国家，因此就用伊拉克和法国出了道题。

要求：给出战场大小 $n$，辐射工兵个数 $m$以及巨炮个数 $k$。伊拉克辐射工兵蹲地部署会污染周围的区域；法国巨炮可以发动远程高伤害大范围打击，但是无法攻击靠近其的单位。攻击范围如图所示（这里不再放图）。伊拉克辐射工兵和法国巨炮自身占用的位置也不安全。询问 $n×n$的战场区域有多少安全的格子，不被伊拉克辐射工兵污染和法国巨炮攻击。

难度：中等

做法：使用 $n×n$的boolean二维数组记录格子是否是不安全的。在输入辐射工兵位置和巨炮位置的时候，逐一枚举他们的攻击范围并做边界检查，将合法的攻击位置都标记为不安全。处理完毕后遍历二维数组，统计剩余安全的区域的个数即可。

注意：
1. 题目中有一个约束， $-50 \le x_i,y_i,o_i,p_i \le 150$。这个信息是想说有可能辐射工兵和巨炮在战场的外面，但还是有可能攻击到 $n×n$的战场区域，因此边界检查就是特别重要的一环。
2. 本题中处理辐射工兵和巨炮的方法是一致的，可以考虑使用方向数组来简化代码，如：

```java
private static final int[][] DESOLATOR = {
    {-1, -1},
    {-1, 0},
    {-1, 1},
    {0, -1},
    {0, 1},
    {1, -1},
    {1, 0},
    {1, 1}
};
```

## A3Q3 初音未来的谜题

这也是我出的一道题，因为我是初音未来的粉丝。简而言之，这道题是“融合怪”，但本身难度不是很大，只是会稍微麻烦一点。

要求：给出目标矩阵大小 $m×n$，以及待解压的字符串 $s$。首先按照题目要求解压字符串$s$，然后将解压后的字符串从左下角开始，逆时针排布 $m×n$的螺旋矩阵。

难度：困难

做法：我不知道怎么讲这个题的做法，因为做法已经原原本本地写在题面上了。我觉得可以分开三步来进行，首先实现一个方法解压字符串，然后再实现一个方法排布螺旋矩阵，最后将排布好的螺旋矩阵输出，比如说：

```java
public static String decompress(String s){
    //...
}


public static char[][] organizeSpiralMatrix(int m, int n, String decompressed){
    //...
}

public static void printMatrix(char[][] matrix){
    //...
}
```

注意：
1. 字符串解压的时候，得到一个字母后，如何得知其重复几次？如何卡住这个数字的字符串的左右边界？
2. 螺旋矩阵转圈的条件有两个，二者命中其一即可：
2.1 数组访问越界
2.2 目标位置的内容已经被填充
3. 螺旋矩阵排布的时候，是否也可以使用方向数组？

## A3Q4 俄罗斯方块

要求：给出俄罗斯方块的游戏棋盘大小 $w,h$。7种方块按输入顺序自由下落，输入的格式是`type l`，`l`为最左下元素的位置。期间优先处理整行的消除，如果俄罗斯方块在消除后还是超过上边界，那么游戏应该立刻提前结束。当方块用完时，或者游戏提前结束时，需要输出结束时的局面。

难度：中等

做法：这个题的做法分以下几步：
- 构建 $(h+3)×w$的游戏棋盘。其中上面3排为`buffer area`，用于检查会不会越界。
- 确定下落方块的具体纵坐标。确定方法是在**边界检查**的基础上检查4个格子是否都为0。如果不是0，那么下落位置就在它的上一格；如果到最后一个位置还全都是0，那么下落位置就在最后一格。
- 在确定纵坐标后，将下落位置填为1。然后通盘检查，看看能否消除，消除成功则将上面的元素全部下移一格 **（不是根据重力自由下落！）**。持续消除直至没有能够消除的行。
- 消除后，检查是否有越界。检查`buffer area`是否有越界，如有越界立刻结束输入的循环。
- 结束后输出棋盘信息。注意不要输出`buffer area`的元素。

注意：这个题细节很多。
- 细节1：必须使用`buffer area`。不使用的话做起来非常困难。
- 细节2：下落方块的纵坐标不能仅仅检查4个位置是不是都是0，比如说下面这种情况放`L 0`是放不进去的。

```
000000
000000
011000
011101
001110
111100
```

- 细节3：消除后，最顶端元素需要变为0。这个好像很简单，但是也是我踩过的坑。

```
010010
111111
010111
110111
011101
101110
```

顶端第二排消除后应该是：

```
000000
010010
010111
110111
011101
101110
```

- 细节4：这个题坐标轴是(0,0)在左上角，这个和传统的认知不太一样。
- 细节5：这个题枚举7种类型的方块是否过于繁杂？使用相对于左下角坐标的偏移方向数组能大大简化代码，如：

```java
private static final int[][] L = {
    {0, 0},
    {0, 1},
    {-1, 0},
    {-2, 0}
};
private static final int[][] S = {
    {0, 0},
    {0, 1},
    {-1, 1},
    {-1, 2}
};
```